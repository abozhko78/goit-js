<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Document</title>
</head>
<body>

<script>
  
  // Масив — це впорядкована структура даних, яка використовується для зберігання колекції елементів. Масиви можуть містити елементи різних типів даних, таких як числа, рядки, булеві значення тощо.
  
  const planets = ['Earth', 'Mars', 'Venus']; // масив рядків
  const numbers = [1, 2, 3, 4, 5]; // масив чисел
  const mixed = ['apple', 10, true]; // масив з елементами різних типів
  
  const planets = ['Earth', 'Mars', 'Venus'];
  console.log(planets[0]); // 'Earth'
  console.log(planets[1]); // 'Mars'
  console.log(planets[2]); // 'Venus'
  
  // Довжина масиву, тобто кількість його елементів, зберігається у властивості length. Це динамічна величина, яка автоматично змінюється під час додавання або видалення елементів.
  
  const planets = ['Earth', 'Mars', 'Venus'];
  console.log(planets.length); // 3
  
  // Індекс останнього елемента
  // Щоб знайти значення останнього елемента масиву, нам потрібно знати його індекс. Індекс останнього елемента можна визначити за допомогою формули довжина_масиву -1.
  // Оскільки індексація елементів масиву починається з 0, а довжина масиву зберігає загальну кількість елементів, віднімаючи 1 від довжини масиву, ми отримуємо індекс останнього елемента.
  
  const planets = ["Earth", "Mars", "Venus"];
  const lastElementIndex = planets.length - 1;
  console.log(planets[lastElementIndex]); // "Venus"
  
  // Присвоєння за посиланням і за значенням
  // Фундаментальною відмінністю складних типів від примітивів є те, як вони зберігаються і копіюються.
  // Примітиви: рядки, числа, буль, null і undefined, під час присвоювання копіюються цілком, за значенням (by value).
  // Зі складними типами все не так. У змінній, якій, наприклад, присвоєно масив, зберігаються не самі значення елементів масиву, а адреса того місця в пам'яті, де цей масив розташовано. Іншими словами — посилання (покажчик) на нього.
  
  let a = 5;
  let b = a;
  console.log(a); // 5
  console.log(b); // 5
  // Присвоєння за значенням, у пам'яті буде створено ще
  // одну ячейку, в яку буде скопійовано значення 5
  
  // Змінимо значення a
  a = 10;
  console.log(a); // 10
  console.log(b); // 5 Значення b не змінилося, оскільки це окрема копія
  
  
  const a = ["Mango", "Poly"];
  const b = a;
  console.log(a); // ["Mango", "Poly"]
  console.log(b); // ["Mango", "Poly"]
  
  // Оскільки a це масив, у b записується посилання на вже наявний у пам'яті масив. Тепер a і b вказують на один і той самий масив.
  // Змінимо масив, замінивши елемент з індексом 1, використовуючи посилання з a.
  // Те, що зберігається в b, також змінилося, тому що b, як і a, просто містить посилання на одне й те саме місце в пам'яті — масив.
  
  const a = ["Mango", "Poly"];
  const b = a;
  
  console.log(a); // ["Mango", "Poly"]
  console.log(b); // ["Mango", "Poly"]
  a[1] = "Jacob";
  console.log(a); // ["Mango", "Jacob"]
  console.log(b); // ["Mango", "Jacob"]
  
  // Результат повторюється, якщо використовувати посилання у змінній b для зміни масиву.
  
  const a = ["Mango", "Poly"];
  const b = a;
  console.log(a); // ["Mango", "Poly"]
  console.log(b); // ["Mango", "Poly"]
  
  a[1] = "Jacob";
  console.log(a); // ["Mango", "Jacob"]
  console.log(b); // ["Mango", "Jacob"]
  
  b[0] = "Ajax";
  console.log(a); // ["Ajax", "Jacob"]
  console.log(b); // ["Ajax", "Jacob"]
  
  // Два масиви ніколи не дорівнюють один одному, навіть якщо вони порожні або в них однакові елементи.
  
  const arr1 = [1, 2, 3];
  const arr2 = [1, 2, 3];
  
  console.log(arr1 === arr2); // false
  console.log([] === []); // false
  
  
  // Приведення типів: масиви
  // Явне і не явне приведення типів масивів здійснюється за необхідності виконати операції або порівняння, які вимагають сумісності типів даних.
    
  // Масив → Рядок
  // При перетворенні масиву в рядок усі елементи масиву об'єднуються в один рядок, розділений комами.
  const array = [1, true, "Poly"];
  console.log(String(array));// "1,true,Poly"
  console.log(array + "5"); // "1,true,Poly5"
  
  // Масив → Число
  // При перетворенні масиву в число алгоритм складається з двох кроків:
  // - спочатку масив приводиться до рядка,
  // - а потім цей рядок приводиться до числового значення.
  // Наприклад, порожній масив приводиться до порожнього рядка, який приводиться до числа 0.
  console.log(Number([])); // 0
  console.log(Number([1])); // 1
  console.log(Number([1, 2, 3])); // NaN
  
  // Масив → Логічне значення (буль)
  // При перетворенні масиву в логічне значення будь-який масив, навіть порожній, перетворюється на true.
  const emptyArray = [];
  const nonEmptyArray = [1, 2, 3];
  
  console.log(Boolean(emptyArray)); // true
  console.log(Boolean(nonEmptyArray)); // true
  
  if(emptyArray) {
    console.log("if is in progress")
  } else {
    console.log("else is not performed")
  }
  
  if(nonEmptyArray) {
    console.log("if is in progress")
  } else {
    console.log("else is not performed")
  }

























</script>

</body>
</html>